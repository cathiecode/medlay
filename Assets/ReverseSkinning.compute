// Unity built-in shader source. Copyright (c) 2016 Unity Technologies. MIT license (see license.txt)

// Generic compute skinning ... with pos, norm, and tangent skinning

#pragma kernel main SKIN_BONESFORVERT=0
#pragma kernel main SKIN_BONESFORVERT=0 SKIN_NORM
#pragma kernel main SKIN_BONESFORVERT=0 SKIN_TANG
#pragma kernel main SKIN_BONESFORVERT=0 SKIN_NORM SKIN_TANG
#pragma kernel main SKIN_BONESFORVERT=1
#pragma kernel main SKIN_BONESFORVERT=1 SKIN_NORM
#pragma kernel main SKIN_BONESFORVERT=1 SKIN_TANG
#pragma kernel main SKIN_BONESFORVERT=1 SKIN_NORM SKIN_TANG
#pragma kernel main SKIN_BONESFORVERT=2
#pragma kernel main SKIN_BONESFORVERT=2 SKIN_NORM
#pragma kernel main SKIN_BONESFORVERT=2 SKIN_TANG
#pragma kernel main SKIN_BONESFORVERT=2 SKIN_NORM SKIN_TANG
#pragma kernel main SKIN_BONESFORVERT=4
#pragma kernel main SKIN_BONESFORVERT=4 SKIN_NORM
#pragma kernel main SKIN_BONESFORVERT=4 SKIN_TANG
#pragma kernel main SKIN_BONESFORVERT=4 SKIN_NORM SKIN_TANG

#include "HLSLSupport.cginc"
#include "Skinning-Util.cginc"

uint g_VertCount;
float4x4 g_WorldToLocal;

SKINNING_GENERIC_VERTEX_BUFFER inVertices;
SKINNING_GENERIC_SKIN_BUFFER inSkin;
SKINNING_GENERIC_VERTEX_RWBUFFER outVertices;
SAMPLER_UNIFORM StructuredBuffer<float4x4> inMatrices;

float4x4 Inverse4x4(float4x4 m)
{
    float n11 = m[0][0], n12 = m[1][0], n13 = m[2][0], n14 = m[3][0];
    float n21 = m[0][1], n22 = m[1][1], n23 = m[2][1], n24 = m[3][1];
    float n31 = m[0][2], n32 = m[1][2], n33 = m[2][2], n34 = m[3][2];
    float n41 = m[0][3], n42 = m[1][3], n43 = m[2][3], n44 = m[3][3];

    float t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
    float t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n11 * n34 * n43 + n13 * n32 * n44 - n11 * n33 * n44;
    float t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n11 * n24 * n43 - n13 * n22 * n44 + n11 * n23 * n44;
    float t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n11 * n24 * n33 + n13 * n22 * n34 - n11 * n23 * n34;

    float det = n11 * t11 + n12 * t12 + n13 * t13 + n14 * t14;
    float idet = 1.0f / det;

    float4x4 res;
    res[0][0] = t11 * idet;
    res[0][1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * idet;
    res[0][2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * idet;
    res[0][3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * idet;

    res[1][0] = t12 * idet;
    res[1][1] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * idet;
    res[1][2] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * idet;
    res[1][3] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * idet;

    res[2][0] = t13 * idet;
    res[2][1] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * idet;
    res[2][2] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * idet;
    res[2][3] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * idet;

    res[3][0] = t14 * idet;
    res[3][1] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * idet;
    res[3][2] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * idet;
    res[3][3] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * idet;

    return res;
}

[numthreads(64, 1, 1)]
void main(uint3 threadID : SV_DispatchThreadID)
{
    const uint t = threadID.x;

    if (t >= g_VertCount)
    {
        return;
    }

    const MeshVertex vert = FetchVert(inVertices, t);
    SkinInfluence si = FetchSkin(inSkin, t);

    float3 vPos = vert.pos.xyz;
#if SKIN_NORM
    float3 vNorm = vert.norm.xyz;
#endif
#if SKIN_TANG
    float3 vTang = vert.tang.xyz;
#endif

    float3 oPos = float3(0, 0, 0);
    float3 oNorm = float3(0, 0, 0);
    float4 oTang = float4(0, 0, 0, 0);

#if SKIN_BONESFORVERT == 0
    uint startIndex = si.index0;
    uint endIndex = FetchSkin(inSkin, t + 1).index0;
    float4x4 blendedMatrix = 0;
    for (uint i = startIndex; i < endIndex; i++)
    {
        uint weightAndIndex = FetchSkin(inSkin, i).index0;
        float weight = float(weightAndIndex >> 16) * (1.0f / 65535.0f);
        uint index = weightAndIndex & 0xFFFF;
        blendedMatrix += inMatrices[index] * weight;
    }
#elif SKIN_BONESFORVERT == 1
    const float4x4 blendedMatrix = inMatrices[si.index0];
#elif SKIN_BONESFORVERT == 2
    const float4x4 blendedMatrix = inMatrices[si.index0] * si.weight0 +
                                   inMatrices[si.index1] * si.weight1;
#elif SKIN_BONESFORVERT == 4
    const float4x4 blendedMatrix = inMatrices[si.index0] * si.weight0 +
                                   inMatrices[si.index1] * si.weight1 +
                                   inMatrices[si.index2] * si.weight2 +
                                   inMatrices[si.index3] * si.weight3;
#endif

    float4x4 totalForwardMatrix = mul(g_WorldToLocal, blendedMatrix);
    float4x4 reverseMatrix = Inverse4x4(totalForwardMatrix);

    MeshVertex ouputVertex;

    ouputVertex.pos = mul(blendedMatrix, float4(vPos, 1)).xyz;

#if SKIN_NORM
    ouputVertex.norm = mul(blendedMatrix, float4(vNorm, 0)).xyz;
#endif

#if SKIN_TANG
    ouputVertex.tang.xyz = mul(blendedMatrix, float4(vTang, 0)).xyz;
    ouputVertex.tang.w = vert.tang.w;
#endif

    StoreVert(outVertices, ouputVertex, t);
}
